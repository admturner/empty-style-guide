---
category: "HRS Code Reference"
order: 1
title: "HRS_MSDB() Class: Microsoft SQL Server Connector"
authors:
  - name: Adam Turner
updated: 2018-08-21
tags: Docs, Microsoft, WordPress, Databases
---

WordPress provides its own class ([`wpdb`](https://codex.wordpress.org/Class_Reference/wpdb)) to handle interactions with its database, but that class can only communicate with MySQL or MariaDB databases. In order to interact with Microsoft SQL Server databases we need to [install the necessary drivers and extensions](../sql-server-drivers/) and then write our own methods for interacting with the SQL Server database.

This document describes the organization and methods used in the HRS Child Theme to connect to external SQL Server databases.

## Overview

This method separates DB connections, queries, and views into different pieces. These individual pieces can be more easily reused and individual parts can be adjusted without having to rewrite the other parts.

We use a dedicated class (`HRS_MSDB`) that resembles the WordPress `wpdb` class and handles the database connections and runs the SQL Server queries. It also provides methods for error handling, debugging, and flushing and closing connections. Instantiating the class with a set of database credentials opens a connection that can then be used to execute a query. A set of helper functions (`hrs-queries.php`) handles making specific queries against specific database tables. These functions act as a sort of go-between between the view functions and the database connector class.

## Structure

The WordPress-MSSQL connector separates data from views and uses two primary files for each:

**Data handlers:**

* `includes/class-msdb-connect.php`: The HRS SQL Server Connector: HRS_MSDB Class. The HRS_MSDB class, when instantiated with valid credentials, opens a connection from WordPress to a SQL Server database. The class provides a variety of methods for interacting with the SQL Server database (currently using the `sqlsvr` PHP extension).

* `includes/hrs-queries.php`: Provides custom database queries for the HRS child theme. A query function in this file instantiates the `HRS_MSDB` class with the command `new HRS_MSDB( $dbuser, $dbpassword, $dbname, $dbhost )` and can then execute a SQL query using the class `get_results()` and `prepare()` methods.

**Views handlers:**

* `includes/hrs-template-tags.php`: This file provides the primary view constructors. These functions request data using `hrs-queries.php` functions and format that data into HTML output for the website. They can either be used as-is in page templates or linked to a shortcode.

* `includes/shortcode-external-content.php`: This file provides functions to hook into the WP Shortcode API to create shortcodes for the display functions in `hrs-template-tags.php`. At the time being these are very basic shortcodes that simply output the content generated by the template tag. In the future they could be made more complex to adjust the parameters of the query itself.

**Database credentials:**

Stored as global constants in `wp-config.php` along with the default WPDB database credentials.

### Example

In order to display a table of job titles and corresponding salary data.

First a content administrator would:

1. Add the target SQL Server connection credentials (user, password, database name, host) to `wp-config.php` if those credentials aren't already saved.
2. Write a function in `includes/hrs-queries.php` that opens a connection using the `HRS_MSDB` class and executes an SLQ query.
3. Write a function in `includes/hrs-template-tags.php` to call the new `hrs-queries.php` function, format the results, and print the output.
4. Create a new shortcode in `includes/shortcode-external-content.php` to handle the output.

A content manager could then:

1. Add the new shortcode tag to a new or existing page to display the content.

## Walkthrough

This walkthrough will demonstrate adding a new connection, making a simple read request, and formatting and displaying the results in order to produce a list of desserts from a Desserts database.

### Step 1: Adding a New Connection

Here we'll add a new connection to a fictional Desserts database.

First we'll add the database credential information to `wp-config.php` as global constants. The default WP Config file (stored either at the site root or one level above) already stores the default WPDB credentials in a format that looks like this:

~~~php
// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define('DB_NAME', 'database_name_here');

/** MySQL database username */
define('DB_USER', 'username_here');

/** MySQL database password */
define('DB_PASSWORD', 'password_here');

/** MySQL hostname */
define('DB_HOST', 'localhost');
~~~

We'll add our own credentials after this section. Add the following variable definitions below `define('DB_HOST')` using the correct database connection information:

~~~php
// ** MS SQL Server settings ** //
/** SQL Server database name */
define('DESSERTS_NAME', 'desserts_database')

/** SQL Server database username */
define('DESSERTS_USER', 'desserts_user')

/** SQL Server database password */
define('DESSERTS_PASSWORD', 'desserts_password')

/** SQL Server database hostname */
define('DESSERTS_HOST', 'localhost')
~~~

### Step 2: Writing a Query

Now that our Desserts database credentials are saved in the private WP Config file, we can move on writing a query to request data from the database.

Open the HRS Queries file at `includes/hrs-queries.php` and add a new function, which we'll call `get_desserts()`:

~~~php
function get_desserts() {
    // Connections and query will go here.
}
~~~

In order to retrieve a list of all the desserts we'll need to:

1. Retrieve the database credentials.
2. Connect to the database.
3. Write and execute an SQL query.
4. Close the database connection.
5. Return the results.

To organize things we'll outline these steps in the `get_desserts()` function:

~~~php
function get_desserts() {
    // Retrieve the database credentials.

    // Connect to the database.

    // Write and execute an SQL query.

    // Close the database connection.

    // Return the results.
}
~~~

#### 1. Retrieve the database credentials

We start with the database credentials, which we've already saved in the WP Config file. (For each of the following steps I'll demonstrate only the relevant snippet of the function.)

~~~php
// Retrieve the database credentials.
$dbuser     = defined( 'DESSERTS_USER' ) ? DESSERTS_USER : '';
$dbpassword = defined( 'DESSERTS_PASSWORD' ) ? DESSERTS_PASSWORD : '';
$dbname     = defined( 'DESSERTS_NAME' ) ? DESSERTS_NAME : '';
$dbhost     = defined( 'DESSERTS_HOST' ) ? DESSERTS_HOST : '';
~~~

This retrieves the database credential constants from WP Config and saves them locally to use in the database connection. (I've used ternary shorthand here to check that the constant is defined before assigning a value to the local variable.)

#### 2. Connect to the database

To open the connection we'll create a new instance of the `HRS_MSDB` class using the stored credentials.

~~~php
// Connect to the database.
$msdb = new \HRS_MSDB( $dbuser, $dbpassword, $dbname, $dbhost );
~~~

(Note the backslash before the class name. The HRS Child Theme uses [PHP namespaces](https://php.net/manual/en/language.namespaces.rationale.php). This backslash refers to the global namespace.)

#### 3. Write and execute an SQL query

Next we'll write and execute an SQL query for the new connection. We want to get a list of desserts with the type "frozen" and "pastry," sorted by dessert name.

The `HRS_MSDB` class provides two methods to help with this process: `get_results()` and `prepare()`. The `prepare()` method will attempt to prepare a SQL Server query for safe execution and will handle placeholders. It must be used with at least one placeholder. The `get_results()` function retrieves a SQL result from the database. You can also use a [SQL Server parameterized query](https://docs.microsoft.com/en-us/sql/connect/php/how-to-perform-parameterized-queries?view=sql-server-2017) instead of using prepare.

Using the prepare method:

~~~php
// Write and execute an SQL query.
$desserts = $msdb->get_results( $msdb->prepare(
    '
    SELECT title, type, calories
    FROM desserts_table
    WHERE type = %s OR type = %s
    ORDER BY %s
    ',
    array( 'frozen', 'pastry', 'title' )
) );
~~~

Using a parameterized query (note that SQL Server query syntax may be finicky when it comes to using a variable for ORDER BY):

~~~php
// Write and execute an SQL query.
$desserts = $msdb->get_results(
    '
    SELECT title, type, calories
    FROM desserts_table
    WHERE type = ? OR type = ?
    ORDER BY title
    ',
    array( 'frozen', 'pastry' )
);
~~~

Using a bare `get_results()` request (this does not escape any content, so only use this if you are not using variables in your SQL statement):

~~~php
// Write and execute an SQL query.
$desserts = $msdb->get_results(
    '
    SELECT title, type, calories
    FROM desserts_table
    ',
);
~~~

#### 4. Close the database connection

The `HRS_MSDB` class has a method to handle both freeing the executed statement and closing the database connection:

~~~php
// Close the database connection.
$msdb->clean();
~~~

#### 5. Return the results

Now that everything is finished -- we've opened a connection, stored the results of an SQL query in a local variable, and flushed and closed the connection -- we're ready to return the results.

~~~php
// Return the results.
return $desserts;
~~~

**Bringing it all together:**

~~~php
function get_desserts() {
    // Retrieve the database credentials.
    $dbuser     = defined( 'DESSERTS_USER' ) ? DESSERTS_USER : '';
    $dbpassword = defined( 'DESSERTS_PASSWORD' ) ? DESSERTS_PASSWORD : '';
    $dbname     = defined( 'DESSERTS_NAME' ) ? DESSERTS_NAME : '';
    $dbhost     = defined( 'DESSERTS_HOST' ) ? DESSERTS_HOST : '';

    // Connect to the database.
    $msdb = new \HRS_MSDB( $dbuser, $dbpassword, $dbname, $dbhost );

    // Write and execute an SQL query.
    $desserts = $msdb->get_results( $msdb->prepare(
        '
        SELECT title, type, calories
        FROM desserts_table
        WHERE type = %s OR type = %s
        ORDER BY %s
        ',
        array( 'frozen', 'pastry', 'title' )
    ) );

    // Close the database connection.
    $msdb->clean();

    // Return the results.
    return $desserts;
}
~~~

Now all we have to do to retrieve an array of dessert data from our Desserts database is to call this function. We're ready to move on to formatting the data for display.

### Step 3: Writing a Display Function

We now have a way to retrieve an array of data from the database. Next we want to display it as a list. We want a simple bulleted list of desserts including each item's type and Calorie count, such as:

* **Donut** (Pastry, 452 Calories)
* **Frozen yogurt** (Frozen, 159 Calories)
* **Ice cream sandwich** (Frozen, 237 Calories)

To do this we'll create a new [template tag](https://codex.wordpress.org/Template_Tags) function. Open the HRS Template Tags file at `includes/hrs-template-tags.php` and add a new function called `list_desserts()`:

~~~php
function list_desserts() {
    // Data retrieval and formatting will go here.
}
~~~

In order to display our list of desserts we'll need to:

1. Retrieve the data.
2. Format the data into HTML.
3. Print the result.

To make things clear, we'll add those steps to our `list_desserts()` function:

~~~php
function list_desserts() {
    // Retrieve the data.

    // Format the data into HTML.

    // Print the result.
}
~~~

#### 1. Retrieve the data

This is a relatively easy step since we've already written a function to get the data from the database. We simply call the `get_desserts()` function along with a quick check that will bail out if nothing is returned. (For each of the following steps I'll demonstrate only the relevant snippet of the function.)

~~~php
// Retrieve the data.
$desserts = get_desserts();

// If `get_desserts()` didn't return any results, stop execution.
if ( ! $desserts ) {
    return false;
}
~~~

This snippet will give us a variable `$desserts`, which will be an array of objects from the Desserts database. Use `print_r( $desserts )` to see the raw data and you'll get something like this:

~~~php
Array (
  [0] => stdClass Object (
    [title] => Donut
    [type] => Pastry
    [calories] => 452
  )
  [1] => stdClass Object (
    [title] => Frozen yogurt
    [type] => Frozen
    [calories] => 159
  )
  [2] => stdClass Object (
    [title] => Ice cream sandwich
    [type] => Frozen
    [calories] => 237
  )
)
~~~

#### 2. Format the data into HTML

We'll loop through the objects in the `$desserts` array to build the list content.

~~~php
// Format the data into HTML.
$list = '';
foreach ( $desserts as $dessert ) {
    $list .= sprintf( __( '<li><strong>%1$s</strong> (%2$s, %3$d Calories)</li>', 'text-domain' ),
        esc_html( $dessert->title ),
        esc_html( $dessert->type ),
        esc_html( $dessert->calories )
    );
}
~~~

#### 3. Print the result

Print the formatted result of the list loop.

~~~php
// Print the result.
printf( '<ul>%s</ul>', $list );
~~~

**Bringing it all together:**

~~~php
function list_desserts() {
    // Retrieve the data.
    $desserts = get_desserts();

    // If `get_desserts()` didn't return any results, stop execution.
    if ( ! $desserts ) {
        return false;
    }

    // Format the data into HTML.
    $list = '';
    foreach ( $desserts as $dessert ) {
        $list .= sprintf( __( '<li><strong>%1$s</strong> (%2$s, %3$d Calories)</li>', 'text-domain' ),
            esc_html( $dessert->title ),
            esc_html( $dessert->type ),
            esc_html( $dessert->calories )
        );
    }

    // Print the result.
    printf( '<ul>%s</ul>', $list );
}
~~~

Now we could add the `list_desserts()` function to any of our template files to display the list of desserts on the site. But for the sake of flexibility we'll take it one step further and create a shortcode to display this list in any post or page content we want without having to edit page templates.

### Step 4: Create a New Shortcode

For this step we'll use the [WordPress Shortcode API](https://codex.wordpress.org/Shortcode_API) to create a shortcode tag to display the desserts list. When we're done users will be able to enter the shortcode `[my_desserts]` anywhere in the site content to generate the list of desserts.

Open the HRS external content shortcodes file at `includes/shortcode-external-content.php`. This is where we'll register the shortcode and handle its behavior:

~~~php
// Register my_desserts shortcode.

// Handle the my_desserts shortcode behavior.
~~~

First hook into the Shortcode API to register the shortcode name and callback function:

~~~php
// Register my_desserts shortcode.
add_shortcode( 'my_desserts', 'my_desserts_list_shortcode' );
~~~

The first parameter `'my_desserts'` defines the name of the shortcode tag (this should be unique to avoid collisions with other shortcodes). The second parameter is the function name of the hook to run when the shortcode is found.

Next, write a new function called `my_desserts_list_shortcode`.

~~~php
// Handle the my_desserts shortcode behavior.
my_desserts_list_shortcode() {
    // Display the desserts list.
}
~~~

All we want the shortcode to do right now is to display the list of desserts. We already have a function that prints the list, so all we need to do here is call that function. **Note that the function called by the shortcode should never produce output of any kind.** Shortcode functions should *return* the text that is to be used to replace the shortcode. Producing the output directly will lead to unexpected results. Since our `list_desserts()` function does produce output, we'll use output buffering to store the output and return it instead of printing it.

~~~php
// Display the desserts list.
ob_start();

list_desserts();

return ob_get_clean();
~~~

**Bringing it all together:**

~~~php
// Register my_desserts shortcode.
add_shortcode( 'my_desserts', 'my_desserts_list_shortcode' );

// Handle the my_desserts shortcode behavior.
my_desserts_list_shortcode() {
    // Display the desserts list.
    ob_start();

    list_desserts();

    return ob_get_clean();
}
~~~

Content managers can now use the `[my_desserts]` shortcode tag anywhere in a post, page, or widget to display the bulleted list of desserts.

This is a very basic shortcode. In the future it may be preferable to use more complex shortcodes that allow for altering the sort order, including or excluding content from the query, limiting the number of results returned, or displaying results in different formats (among other options).

## System Requirements

WordPress uses PHP to handle communication with the database so we have to install the necessary PHP extensions. The HRS Child Theme requires the following packages be installed on the server:

* PHP 7.0+
* [Microsoft ODBC Driver 17 for SQL Server](https://docs.microsoft.com/en-us/sql/connect/odbc/linux-mac/installing-the-microsoft-odbc-driver-for-sql-server?view=sql-server-2017) (`msodbcsql17`)
* ODBC libraries for UNIX, development files (`unixodbc-dev`)
* PHP [SQLSVR extension](http://php.net/manual/en/book.sqlsrv.php) (`sqlsrv`)
* (We also install the PHP PDO_SQLSRV extension, `pdo_sqlsrv`, though we don't use PDO at this time.)
